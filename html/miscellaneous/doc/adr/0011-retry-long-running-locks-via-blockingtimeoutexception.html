<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>11. Retry long-running locks via BlockingTimeoutException &mdash; OSS AtlasDB develop documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/release-notes.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="12. Batch timestamp requests on the client side" href="0012-batch-timestamp-requests-on-the-client-side.html" />
    <link rel="prev" title="10. Use partial row complete cell batching in getTimestampsByCell" href="0010-use-partial-row-complete-cell-batching-in-gettimestampsbycell.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> OSS AtlasDB
          </a>
              <div class="version">
                develop
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../overview/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../schemas/index.html">Schemas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../transactions/index.html">Transactions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../configuration/index.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cluster_management/index.html">Cluster Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../services/index.html">Services</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../performance/index.html">Performance Testing</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Miscellaneous</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../asynchronous-initialization.html">Asynchronous Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing.html">Contributing to AtlasDB</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Architecture Decision Records</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="0001-record-architecture-decisions.html">1. Record architecture decisions</a></li>
<li class="toctree-l3"><a class="reference internal" href="0002-prevent-tables-from-being-creating-simultaneously-in-cassandra-via-a-locks-table.html">2. Prevent tables from being created simultaneously in cassandra via a locks table</a></li>
<li class="toctree-l3"><a class="reference internal" href="0003-tagging-for-releases-and-long-term-support.html">3. Tagging for releases and long-term support</a></li>
<li class="toctree-l3"><a class="reference internal" href="0004-create-schema-lock-table-via-a-one-off-cli-command.html">4. Create schema lock table via a one off CLI command</a></li>
<li class="toctree-l3"><a class="reference internal" href="0005-stop-allowing-embedded-lock-and-timestamp-services-in-production.html">5. stop allowing embedded lock and timestamp services in production</a></li>
<li class="toctree-l3"><a class="reference internal" href="0006-create-schema-lock-table-using-configuration.html">6. Create schema lock table using configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="0007-use-cql-for-column-paging-for-sweep.html">7. Use CQL for column paging for sweep</a></li>
<li class="toctree-l3"><a class="reference internal" href="0008-add-heartbeat-for-schema-lock-holders.html">8. Adding Heartbeat for Schema Lock Holders</a></li>
<li class="toctree-l3"><a class="reference internal" href="0009-load-and-read-streams-in-same-transaction.html">9. Load and Read Streams in the Same Transaction</a></li>
<li class="toctree-l3"><a class="reference internal" href="0010-use-partial-row-complete-cell-batching-in-gettimestampsbycell.html">10. Use partial row complete cell batching in getTimestampsByCell</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">11. Retry long-running locks via BlockingTimeoutException</a></li>
<li class="toctree-l3"><a class="reference internal" href="0012-batch-timestamp-requests-on-the-client-side.html">12. Batch timestamp requests on the client side</a></li>
<li class="toctree-l3"><a class="reference internal" href="0013-write-cassandra-tombstones-and-sentinels-with-a-fresh-cassandra-timestamp.html">13. Write Cassandra tombstones and sentinels with a fresh Cassandra timestamp</a></li>
<li class="toctree-l3"><a class="reference internal" href="0014-targeted-sweep.html">14. Targeted Sweep</a></li>
<li class="toctree-l3"><a class="reference internal" href="0015-batch-asynchronous-post-transaction-unlock-calls.html">15. Batch asynchronous post-transaction unlock calls</a></li>
<li class="toctree-l3"><a class="reference internal" href="0016-use-tickets-encoding-for-transactions.html">16. Use the tickets encoding for the transactions table (_transactions2)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../kvs-status-check.html">KeyValueService Status</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../dropwizard-metrics.html">AtlasDB Metrics</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../troubleshooting/index.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes/index.html">Releases</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">OSS AtlasDB</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Miscellaneous</a> &raquo;</li>
          <li><a href="index.html">Architecture Decision Records</a> &raquo;</li>
      <li>11. Retry long-running locks via BlockingTimeoutException</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/palantir/atlasdb/blob/develop/docs/source/miscellaneous/doc/adr/0011-retry-long-running-locks-via-blockingtimeoutexception.md" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="retry-long-running-locks-via-blockingtimeoutexception">
<h1>11. Retry long-running locks via BlockingTimeoutException<a class="headerlink" href="#retry-long-running-locks-via-blockingtimeoutexception" title="Permalink to this headline">¶</a></h1>
<p>Date: 08/05/2017</p>
<div class="section" id="status">
<h2>Status<a class="headerlink" href="#status" title="Permalink to this headline">¶</a></h2>
<p>Accepted</p>
<p>Note that this decision applies only to locks that were taken out via the legacy (V1) lock service. We have since
implemented an asynchronous lock service which is used for all transactional locks; blocking timeouts are not relevant
there.</p>
</div>
<div class="section" id="context">
<h2>Context<a class="headerlink" href="#context" title="Permalink to this headline">¶</a></h2>
<p>Our implementation of AtlasDB clients and the TimeLock server were interacting in ways that were causing the TimeLock
server to experience large thread buildups when running with HTTP/2. This manifested in
<a class="reference external" href="https://github.com/palantir/atlasdb/issues/1680">issue #1680</a>. The issue was eventually root caused to long-running
lock requests in excess of the Jetty idle timeout; the server would close the relevant HTTP/2 stream, but <em>not</em>
free up the resources consumed by the request. Eventually, all server threads on the leader node would be busy handling
lock requests that had timed out. The leader would thus not respond to pings, resulting in other nodes proposing
leadership. This is problematic as leader elections cause all locks to be lost, and thus most
inflight transactions will fail. A concrete trace is as follows:</p>
<ol class="simple">
<li>Client A acquires lock L</li>
<li>Client B blocks on acquiring lock L, with request B1</li>
<li>The idle timeout for Client B’s connection runs out, and we close the HTTP/2 stream</li>
<li>Client B retries, and blocks on acquiring lock L, with request B2</li>
<li>Client A releases L</li>
<li>Request B1 is granted, but client B is no longer listening on it</li>
<li>(2 minutes) The idle timeout for Client B will expire four times, and Client B retries with requests B3, B4, B5, B6</li>
<li>The lock granted to request B1 is reaped, and request B2 is granted, but client B is not listening for it</li>
</ol>
<p>Since we retry every 30 seconds by default but only “service” one request every 2 minutes and 5 seconds, we accumulate
a backlog of requests. Also, observe that setting the idle timeout to 2 minutes and 5 seconds does not solve the
problem (though it does mitigate it), since multiple clients may be blocking on acquiring the same lock.</p>
</div>
<div class="section" id="decision">
<h2>Decision<a class="headerlink" href="#decision" title="Permalink to this headline">¶</a></h2>
<div class="section" id="time-limiting-lock-requests">
<h3>Time Limiting Lock Requests<a class="headerlink" href="#time-limiting-lock-requests" title="Permalink to this headline">¶</a></h3>
<p>We decided that solutions to this problem should prevent the above pattern by satisfying one or both of the following:</p>
<ol class="simple">
<li>Prevent the idle timeout from reasonably occurring.</li>
<li>Ensure resources are freed if the idle timeout triggers.</li>
</ol>
<p>We introduced a time limit for which a lock request is allowed to block - we call this the <em>blocking timeout</em>.
This is set to be lower than the Jetty idle timeout by a margin, thus achieving requirement 1. Even if we lose the
race, we will still free the resources shortly after, thus achieving requirement 2.</p>
<p>In the event that a lock request blocks for longer than the blocking timeout, we interrupt the requesting thread and
notify the client by sending a <code class="docutils literal notranslate"><span class="pre">SerializableError</span></code> which wraps a <code class="docutils literal notranslate"><span class="pre">BlockingTimeoutException</span></code>. Upon receiving a
503, a client checks the nature of the error occurring on the server; in the event of <code class="docutils literal notranslate"><span class="pre">BlockingTimeoutException</span></code>,
we retry on the same node, and reset the counter of the number of times we’ve failed to zero.</p>
<p>The timeout mechanism is implemented using Guava’s <code class="docutils literal notranslate"><span class="pre">TimeLimiter</span></code>, and server time is thus considered authoritative; we
believe this is reasonable as it is used for both our time limiting and for Jetty’s handling of idle timeouts. Thus,
we are relatively resilient to clock drift relative to the client or to other nodes in the TimeLock cluster.</p>
</div>
<div class="section" id="alternatives-considered">
<h3>Alternatives Considered<a class="headerlink" href="#alternatives-considered" title="Permalink to this headline">¶</a></h3>
<div class="section" id="significantly-increase-the-jetty-idle-timeout">
<h4>1. Significantly increase the Jetty idle timeout<a class="headerlink" href="#significantly-increase-the-jetty-idle-timeout" title="Permalink to this headline">¶</a></h4>
<p>We could have configured the recommended idle timeout for TimeLock to be substantially longer than we expect any lock
request to reasonably block for, such as 1 day.</p>
<p>This solution is advantageous in that it is simple. However, the current default of 30 seconds is already longer than
we would expect any lock requests to block for. Furthermore, in the event of client or link failures, it would be
possible that resources would be unproductively allocated to the associated connections for longer periods of time.
We would also introduce a dependency on the idle timeout on the HTTP client-side, which would also need to be
increased to account for this (the current default is 60 seconds).</p>
</div>
<div class="section" id="convert-the-lock-service-to-a-non-blocking-api">
<h4>2. Convert the lock service to a non-blocking API<a class="headerlink" href="#convert-the-lock-service-to-a-non-blocking-api" title="Permalink to this headline">¶</a></h4>
<p>We could have changed the lock API such that lock requests return immediately regardless of whether the lock being
asked for is available or not. If any lock being asked for was not available yet, the server would return a token
indicating that the request was to be satisfied. The client can then, at a later time, poll the server with its token
to ask if its request had been satisfied; alternatively, we could investigate HTTP/2 or WebSocket server push.</p>
<p>This solution is likely to be the best long-term approach, though it does involve a significant change in the API
of the lock service which we would prefer not to make at this time.</p>
</div>
<div class="section" id="implement-connection-keep-alives-heartbeats">
<h4>3. Implement connection keep-alives / heartbeats<a class="headerlink" href="#implement-connection-keep-alives-heartbeats" title="Permalink to this headline">¶</a></h4>
<p>We close the connection if no bytes have been sent or received for the idle timeout. Thus, we can reset this timeout
by sending a <em>heartbeat message</em> from the client to the server or vice versa, at a frequency higher than the idle
timeout. We would probably prefer this to live on the server, since the idle timeout is configured on the server-side.</p>
<p>This solution seems reasonable, though it does not appear to readily be supported by Jetty.</p>
</div>
<div class="section" id="send-a-last-gasp-message-to-the-lock-service-to-free-resources-before-the-stream-closes">
<h4>4. Send a last-gasp message to the lock service to free resources before the stream closes<a class="headerlink" href="#send-a-last-gasp-message-to-the-lock-service-to-free-resources-before-the-stream-closes" title="Permalink to this headline">¶</a></h4>
<p>An idea we considered was to have Jetty free resources on the lock service before closing the HTTP/2 stream.</p>
<p>This solution appears to be the cleanest of the “free resources”-based solutions, including the one we chose to
implement. Unfortunately, while this feature has been requested in Jetty, as at time of writing this has not
been implemented yet; see <a class="reference external" href="https://github.com/eclipse/jetty.project/issues/824">Jetty issue #824</a>.</p>
</div>
<div class="section" id="have-clients-truncate-individual-requests-to-the-idle-timeout">
<h4>5. Have clients truncate individual requests to the idle timeout<a class="headerlink" href="#have-clients-truncate-individual-requests-to-the-idle-timeout" title="Permalink to this headline">¶</a></h4>
<p>An alternative to having the server return <code class="docutils literal notranslate"><span class="pre">BlockingTimeoutException</span></code>s on long-running requests would be for clients
to trim down any requests to an appropriate length (or, in the case of <code class="docutils literal notranslate"><span class="pre">BLOCK_INDEFINITELY</span></code>, indefinitely send
requests of a suitable length). For example, with the default idle timeout of 30 seconds, a client wishing to block
for 45 seconds could send a lock request that blocks for 30 seconds, and upon failure submit another request that
blocks for just under 15 seconds (suitably accounting for network overheads).</p>
<p>This solution is relatively similar to what was implemented, though it requires clients to know what the
aforementioned “appropriate length” should be (it needs to be the idle timeout or less) which is inappropriate as
that timeout is configured on the server side.</p>
</div>
<div class="section" id="implement-a-magic-http-status-code-or-header-to-ask-clients-to-retry">
<h4>6. Implement a “magic” HTTP status code or header to ask clients to retry<a class="headerlink" href="#implement-a-magic-http-status-code-or-header-to-ask-clients-to-retry" title="Permalink to this headline">¶</a></h4>
<p>An alternative to serializing exceptions into <code class="docutils literal notranslate"><span class="pre">SerializableError</span></code>s could be defining a specific HTTP status code
and/or custom header to indicate that a blocking timeout has occurred and/or clients should retry. This is used
in practice e.g. in nginx, where a 495 indicates an error with a client’s SSL certificates.</p>
<p>This solution would be simpler than serializing exceptions; our existing <code class="docutils literal notranslate"><span class="pre">AtlasDbErrorDecoder</span></code> already switched on the
status code returned in an HTTP response. However, we prefer not to introduce any custom status codes where feasible
(since clients are unlikely to understand these status codes). A similar argument, though perhaps weaker, applies
for headers as well.</p>
</div>
</div>
</div>
<div class="section" id="consequences">
<h2>Consequences<a class="headerlink" href="#consequences" title="Permalink to this headline">¶</a></h2>
<div class="section" id="block-for-at-most-behaviour">
<h3>BLOCK_FOR_AT_MOST Behaviour<a class="headerlink" href="#block-for-at-most-behaviour" title="Permalink to this headline">¶</a></h3>
<p>After implementation of the above, lock requests that block for less than the idle timeout, or that are
<code class="docutils literal notranslate"><span class="pre">BLOCK_INDEFINITELY</span></code> will behave correctly. However, lock requests that block for more than the idle timeout will
be incorrect:</p>
<ol class="simple">
<li>Client A acquires lock L and repeatedly refreshes it</li>
<li>(T = 0) Client B blocks on L; it wants to block for at most 45 seconds.</li>
<li>(T = 30) Client B receives a <code class="docutils literal notranslate"><span class="pre">BlockingTimeoutException</span></code>, and retries - it blocks again on L for at most 45 seconds</li>
<li>(T = 30k, for positive integer k) Client B receives a <code class="docutils literal notranslate"><span class="pre">BlockingTimeoutException</span></code> and retries on L…</li>
</ol>
<p>They will actually behave like <code class="docutils literal notranslate"><span class="pre">BLOCK_INDEFINITELY</span></code> requests unless the client retries correctly, by suitably
reducing the blocking duration of lock requests when retrying. We can implement this by having lock service clients
modify their lock requests on retrying, though that should be the subject of a separate implementation and separate
ADR (as there are some subtleties involving which sources of time one treats as authoritative, and it’s also not
certain that an authoritative source of time is strictly necessary).</p>
</div>
<div class="section" id="exception-serialization">
<h3>Exception Serialization<a class="headerlink" href="#exception-serialization" title="Permalink to this headline">¶</a></h3>
<p>Exception serialization was changed. Previously, if contacting a node that was not the leader we would send a 503
with an empty response; otherwise, we would throw a <code class="docutils literal notranslate"><span class="pre">FeignException</span></code> with the underlying cause and stack trace as
a string. We now serialize <code class="docutils literal notranslate"><span class="pre">NotCurrentLeaderException</span></code> and the new <code class="docutils literal notranslate"><span class="pre">BlockingTimeoutException</span></code> in a manner compatible
with the Palantir <a class="reference external" href="https://github.com/palantir/http-remoting/">http-remoting library</a>, and throw an
<code class="docutils literal notranslate"><span class="pre">AtlasDbRemoteException</span></code> including serialized information about said exception.</p>
<p>This also means that receiving a 503 does not necessarily mean that one is not talking to the leader; one should
interpret the message body of the HTTP response to see what caused said 503. We believe this is a positive change, as
services may be unavailable for reasons other than not being the leader.</p>
</div>
<div class="section" id="fairness-and-starvation">
<h3>Fairness and Starvation<a class="headerlink" href="#fairness-and-starvation" title="Permalink to this headline">¶</a></h3>
<p>Lock requests were previously fair - that is, if thread A blocks on acquiring the <code class="docutils literal notranslate"><span class="pre">LockServerSync</span></code> for a given
lock before thread B, then under normal circumstances (barring exceptions, interruption or leader election),
A would acquire the lock before B. While this is still true at the thread synchronization level, it no longer
necessarily holds at the application layer, since it is possible that A would timeout and be interrupted, the lock
would become available and then B would grab it before A. As a consequence of this, starvation becomes possible.
We believe this is acceptable, as lock requests remain fair as long as none of them blocks for longer than the idle
timeout, and blocking for longer than the idle timeout is considered unexpected. Furthermore, under previous behaviour
with HTTP/2, the lock request for A would never succeed as far as the client was concerned, owing to the retry problems
flagged in <a class="reference external" href="https://github.com/palantir/atlasdb/issues/1680">issue #1680</a>. If clients not using HTTP/2 wish to avoid
this behaviour, they need not use this feature at all (it is configurable).</p>
</div>
<div class="section" id="configuration">
<h3>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h3>
<p>TimeLock has an additional configuration parameter, though this is non-breaking as we provide a sensible default.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="0010-use-partial-row-complete-cell-batching-in-gettimestampsbycell.html" class="btn btn-neutral float-left" title="10. Use partial row complete cell batching in getTimestampsByCell" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="0012-batch-timestamp-requests-on-the-client-side.html" class="btn btn-neutral float-right" title="12. Batch timestamp requests on the client side" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017, Palantir Technologies.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>