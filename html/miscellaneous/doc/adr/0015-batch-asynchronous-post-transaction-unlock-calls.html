

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>15. Batch asynchronous post-transaction unlock calls &mdash; OSS AtlasDB develop documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/release-notes.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="16. Use the tickets encoding for the transactions table (_transactions2)" href="0016-use-tickets-encoding-for-transactions.html" />
    <link rel="prev" title="14. Targeted Sweep" href="0014-targeted-sweep.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> OSS AtlasDB
          

          
          </a>

          
            
            
              <div class="version">
                develop
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../overview/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../schemas/index.html">Schemas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../transactions/index.html">Transactions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../configuration/index.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cluster_management/index.html">Cluster Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../services/index.html">Services</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../performance/index.html">Performance Testing</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Miscellaneous</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../asynchronous-initialization.html">Asynchronous Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing.html">Contributing to AtlasDB</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Architecture Decision Records</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="0001-record-architecture-decisions.html">1. Record architecture decisions</a></li>
<li class="toctree-l3"><a class="reference internal" href="0002-prevent-tables-from-being-creating-simultaneously-in-cassandra-via-a-locks-table.html">2. Prevent tables from being created simultaneously in cassandra via a locks table</a></li>
<li class="toctree-l3"><a class="reference internal" href="0003-tagging-for-releases-and-long-term-support.html">3. Tagging for releases and long-term support</a></li>
<li class="toctree-l3"><a class="reference internal" href="0004-create-schema-lock-table-via-a-one-off-cli-command.html">4. Create schema lock table via a one off CLI command</a></li>
<li class="toctree-l3"><a class="reference internal" href="0005-stop-allowing-embedded-lock-and-timestamp-services-in-production.html">5. stop allowing embedded lock and timestamp services in production</a></li>
<li class="toctree-l3"><a class="reference internal" href="0006-create-schema-lock-table-using-configuration.html">6. Create schema lock table using configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="0007-use-cql-for-column-paging-for-sweep.html">7. Use CQL for column paging for sweep</a></li>
<li class="toctree-l3"><a class="reference internal" href="0008-add-heartbeat-for-schema-lock-holders.html">8. Adding Heartbeat for Schema Lock Holders</a></li>
<li class="toctree-l3"><a class="reference internal" href="0009-load-and-read-streams-in-same-transaction.html">9. Load and Read Streams in the Same Transaction</a></li>
<li class="toctree-l3"><a class="reference internal" href="0010-use-partial-row-complete-cell-batching-in-gettimestampsbycell.html">10. Use partial row complete cell batching in getTimestampsByCell</a></li>
<li class="toctree-l3"><a class="reference internal" href="0011-retry-long-running-locks-via-blockingtimeoutexception.html">11. Retry long-running locks via BlockingTimeoutException</a></li>
<li class="toctree-l3"><a class="reference internal" href="0012-batch-timestamp-requests-on-the-client-side.html">12. Batch timestamp requests on the client side</a></li>
<li class="toctree-l3"><a class="reference internal" href="0013-write-cassandra-tombstones-and-sentinels-with-a-fresh-cassandra-timestamp.html">13. Write Cassandra tombstones and sentinels with a fresh Cassandra timestamp</a></li>
<li class="toctree-l3"><a class="reference internal" href="0014-targeted-sweep.html">14. Targeted Sweep</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">15. Batch asynchronous post-transaction unlock calls</a></li>
<li class="toctree-l3"><a class="reference internal" href="0016-use-tickets-encoding-for-transactions.html">16. Use the tickets encoding for the transactions table (_transactions2)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../kvs-status-check.html">KeyValueService Status</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../dropwizard-metrics.html">AtlasDB Metrics</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../troubleshooting/index.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes/index.html">Releases</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">OSS AtlasDB</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Miscellaneous</a> &raquo;</li>
        
          <li><a href="index.html">Architecture Decision Records</a> &raquo;</li>
        
      <li>15. Batch asynchronous post-transaction unlock calls</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="https://github.com/palantir/atlasdb/blob/develop/docs/source/miscellaneous/doc/adr/0015-batch-asynchronous-post-transaction-unlock-calls.md" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="batch-asynchronous-post-transaction-unlock-calls">
<h1>15. Batch asynchronous post-transaction unlock calls<a class="headerlink" href="#batch-asynchronous-post-transaction-unlock-calls" title="Permalink to this headline">¶</a></h1>
<p>Date: 28/06/2018</p>
<div class="section" id="status">
<h2>Status<a class="headerlink" href="#status" title="Permalink to this headline">¶</a></h2>
<p>Accepted</p>
<p>Functionally, this decision remains accepted.
The implementation has been superseded; we now use Disruptor Autobatchers.</p>
</div>
<div class="section" id="context">
<h2>Context<a class="headerlink" href="#context" title="Permalink to this headline">¶</a></h2>
<p>As part of the AtlasDB transaction protocol, write transactions acquire locks from the lock service. They typically
acquire two types of locks:</p>
<ul class="simple">
<li>An <em>immutable timestamp lock</em>, which AtlasDB uses as an estimate of the oldest running write transaction. The
state of the database at timestamps less than the lowest active immutable timestamp lock is considered immutable, and
thus eligible for cleanup by Sweep.</li>
<li><em>Row locks</em> and <em>cell locks</em> (depending on the conflict handler of the tables involved in a write transaction) for
rows or cells being written to. These locks are used to prevent multiple concurrent transactions from simultaneously
writing to the same rows and committing.</li>
</ul>
<p>Transactions may also acquire additional locks as part of AtlasDB’s pre-commit condition framework. These conditions
are arbitrary and we thus do not focus on optimising these.</p>
<p>After a transaction commits, it needs to release the locks it acquired as part of the transaction protocol. Releasing
the immutable timestamp lock helps AtlasDB keep as few stale versions of data around as possible (which factors into
the performance of certain read query patterns); releasing row and cell locks allows other transactions that need to
update these to proceed.</p>
<p>Currently, these locks are released synchronously and separately after a transaction commits. Thus, there is an
overhead of two lock service calls between a transaction successfully committing and control being returned to
the user.</p>
<p>Correctness of the transaction protocol is not compromised even if these locks are not released (though an effort
should be made to release them for performance reasons). Consider that it is permissible for an AtlasDB client to
crash after performing <code class="docutils literal notranslate"><span class="pre">putUnlessExists</span></code> into the transactions table, in which case the transaction is considered
committed.</p>
</div>
<div class="section" id="decision">
<h2>Decision<a class="headerlink" href="#decision" title="Permalink to this headline">¶</a></h2>
<p>Instead of releasing the locks synchronously, release them asynchronously so that control is returned to the user very
quickly after transaction commit. However, maintaining relatively low latency between transaction commit and unlock
is important to avoid unnecessarily blocking other writers or sweep.</p>
<p>Two main designs were considered:</p>
<ol class="simple">
<li>Maintain a thread pool of <code class="docutils literal notranslate"><span class="pre">N</span></code> consumer threads and a work queue of tokens to be unlocked. Transactions that commit
place their lock tokens on this queue; consumers pull tokens off the queue and make unlock requests to the lock
service.</li>
<li>Maintain a concurrent set of tokens that need to be unlocked; transactions that commit place their lock tokens
in this set, and an executor asynchronously unlocks these tokens.</li>
</ol>
<p>Solution 1 is simpler than solution 2 in terms of implementation. However, we opted for solution 2 for various reasons.
Firstly, the latency provided by solution 1 is very sensitive to choosing <code class="docutils literal notranslate"><span class="pre">N</span></code> well - choosing too small <code class="docutils literal notranslate"><span class="pre">N</span></code> means that
there will be a noticeable gap between transaction commit and the relevant locks being unlocked. Conversely, choosing
too large <code class="docutils literal notranslate"><span class="pre">N</span></code> incurs unnecessary overhead. Choosing a value of <code class="docutils literal notranslate"><span class="pre">N</span></code> in general is difficult and would likely require
tuning depending on individual deployment and product read and write patterns, which is unscalable.</p>
<p>Solution 2 also decreases the load placed on the lock service, as fewer unlock requests need to be made.</p>
<p>In our implementation of solution 2, we use a single-threaded executor. This means that on average the additional
latency we incur is about 0.5 RPCs on the lock service (assuming that that makes up a majority of time spent in
unlocking tokens - it is the only network call involved).</p>
<div class="section" id="tryunlock-api">
<h3>tryUnlock() API<a class="headerlink" href="#tryunlock-api" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">TimelockService</span></code> now exposes a <code class="docutils literal notranslate"><span class="pre">tryUnlock()</span></code> API, which functions much like a regular <code class="docutils literal notranslate"><span class="pre">unlock()</span></code> except that the user
does not need to wait for the operation to complete. This API is only exposed in Java (not over HTTP).</p>
<p>This is implemented as a new default method on the <code class="docutils literal notranslate"><span class="pre">TimelockService</span></code> that delegates to <code class="docutils literal notranslate"><span class="pre">unlock()</span></code>; usefully, remote
Feign proxies calling <code class="docutils literal notranslate"><span class="pre">tryUnlock()</span></code> will make an RPC for standard <code class="docutils literal notranslate"><span class="pre">unlock()</span></code>. This also gives us backwards
compatiblity; a new AtlasDB/TimeLock client can talk to an old TimeLock server that has no knowledge of this endpoint.</p>
</div>
<div class="section" id="concurrency-model">
<h3>Concurrency Model<a class="headerlink" href="#concurrency-model" title="Permalink to this headline">¶</a></h3>
<p>It is essential that adding an element to the set of outstanding tokens is efficient; yet, we also need to ensure that
no token is left behind (at least indefinitely). We thus guard the concurrent set by a (Java) lock that permits both
exclusive and shared modes of access.</p>
<p>Transactions that enqueue lock tokens to be unlocked perform the following steps:</p>
<ol class="simple">
<li>Acquire the set lock in shared mode.</li>
<li>Read a reference to the set of tokens to be unlocked.</li>
<li>Add lock tokens to the set of tokens to be unlocked.</li>
<li>Release the set lock.</li>
<li>If no task is scheduled, then schedule a task by setting a ‘task scheduled’ boolean flag.
This uses compare-and-set, so only one task will be scheduled while no task is running.</li>
</ol>
<p>For this to be safe, the set used must be a concurrent set.</p>
<p>The task that unlocks tokens in the set performs the following steps:</p>
<ol class="simple">
<li>Un-set the task scheduled flag.</li>
<li>Acquire the set lock in exclusive mode.</li>
<li>Read a reference to the set of tokens to be unlocked.</li>
<li>Write the set reference to point to a new set.</li>
<li>Release the set lock.</li>
<li>Unlock all tokens in the set read in step 3.</li>
</ol>
<p>This model is trivially <em>safe</em>, in that no token that wasn’t enqueued can ever be unlocked, since all tokens that can
ever become unlocked must have been added in step 3 of enqueueing, and unlocking a lock token is idempotent modulo
a UUID clash.</p>
<p>More interestingly, we can guarantee <em>liveness</em> - every token that was enqueued will be unlocked in the absence of
thread death. If an enqueue has a successful compare-and-set in step 5, then the token must be in the set
(and is visible, because we synchronize on the set lock). If an enqueue does <em>not</em> have a successful compare-and-set,
then some thread must already be scheduled to perform the unlock, and once it does the token must be in the relevant
set (and again must be visible, because we synchronize on the set lock).</p>
<p>To avoid issues with starving unlocks, we use a fair lock scheme. Once the unlocking thread attempts to acquire the set
lock, enqueues that are still running may finish, but fresh calls to enqueue will only be able to acquire the set lock
after the unlocking thread has acquired and released it. This may have lower throughput than an unfair lock,
but we deemed it necessary as ‘readers’ (committing transactions) far exceed ‘writers’ (the unlocking thread) -
otherwise, the unlocking thread might be starved of the lock.</p>
</div>
<div class="section" id="timelock-failures">
<h3>TimeLock Failures<a class="headerlink" href="#timelock-failures" title="Permalink to this headline">¶</a></h3>
<p>In some embodiments, the lock service is provided by a remote TimeLock server that may fail requests. There is retry
logic at the transport layer underneath us.</p>
<p>Previously, running a transaction task would throw an exception if unlocking row locks or the immutable timestamp
failed; we now allow user code to proceed and only emit diagnostic logs indicating that the unlock operation failed.
This is a safe change, as throwing would not make the locks become available again, and user code cannot safely
assume that locks used by a transaction are free after it commits (since another thread may well have acquired them).</p>
<p>In practice, locks will be released after a timeout if they are not refreshed by a client. This means that not
retrying unlocks is safe, as long as we do not continue to attempt to refresh the lock. AtlasDB clients automatically
refresh locks they acquire; we ensure that a token being unlocked is synchronously removed from the set of locks
to refresh <em>before</em> it is put on the unlock queue.</p>
</div>
</div>
<div class="section" id="consequences">
<h2>Consequences<a class="headerlink" href="#consequences" title="Permalink to this headline">¶</a></h2>
<div class="section" id="improvements">
<h3>Improvements<a class="headerlink" href="#improvements" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Transactions no longer need to wait for their immutable timestamp lock and row/cell write locks to be unlocked
before returning. We anticipate this will make transactions faster (from a user-code perspective) by two
round-trips to the lock service. In many deployments, the lock service is a remote TimeLock server, meaning that
we save two network calls.</li>
<li>Transactions can now succeed even if there were problems when unlocking locks after the transaction committed.</li>
<li>Load on the TimeLock server will be reduced, as fewer unlock calls need to be made (though each call is larger and
the total number of tokens is still the same, constant overheads e.g. of the transport layer will be reduced).</li>
</ul>
</div>
<div class="section" id="drawbacks">
<h3>Drawbacks<a class="headerlink" href="#drawbacks" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Transactions may hold row locks for an average of half a round-trip time between an AtlasDB client and TimeLock
longer. This is partially mitigated by TimeLock load being lower (feeding in to performance improvement across
multiple calls in the transaction protocol).</li>
<li>One background thread is allocated to unlock the locks where needed, which may incur some overhead in deployments
with small hardware.</li>
</ul>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="0016-use-tickets-encoding-for-transactions.html" class="btn btn-neutral float-right" title="16. Use the tickets encoding for the transactions table (_transactions2)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="0014-targeted-sweep.html" class="btn btn-neutral float-left" title="14. Targeted Sweep" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2017, Palantir Technologies.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>